{"task_id": "HumanEval/0", "solution": "from typing import List\nfrom itertools import combinations\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    \"\"\"\n    # Generate all possible pairs of numbers\n    pairs = [(num1, num2) for num1, num2 in combinations(numbers, 2)\n               for num1, num2 in combinations(numbers, 2)]\n\n    # Filter pairs with distance less than threshold\n    close_pairs = [(num1, num2) for num1, num2 in pairs if abs(num1 - num2) < threshold]\n\n    # Check if there are any close pairs\n    return any(abs(num1 - num2) < threshold for num1, num2 in close_pairs)\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\nthreshold = 0.5"}
{"task_id": "HumanEval/1", "solution": "from typing import List\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    Returns a list of strings, where each string is a group of balanced parentheses.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or not is_balanced(stack[-1]):\n                stack.pop()\n            continue\n            # If the stack is empty or the last character is not balanced, ignore it\n        else:\n            stack.pop()\n    if not stack:\n        return []\n    return [char for char in stack]\ndef is_balanced(s: str) -> bool:\n    \"\"\"\n    Checks if a string is balanced by comparing each character with the corresponding opening parenthesis\n    in the same position.\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or not is_balanced(stack[-1]):\n                return False\n            # If the stack is empty or the last character is not balanced, return False\n    return not stack or not all(char in '()' for char in stack)"}
{"task_id": "HumanEval/2", "solution": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Args:\n    number (float): A positive floating point number.\n\n    Returns:\n    float: The decimal part of the number.\n    \"\"\"\n    # Get the integer part of the number\n    integer_part = int(number)\n    \n    # Calculate the decimal part\n    decimal_part = number - integer_part\n    \n    # Return the decimal part\n    return decimal_part"}
{"task_id": "HumanEval/3", "solution": "from typing import List\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\"\n    You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"task_id": "HumanEval/4", "solution": "from typing import List"}
{"task_id": "HumanEval/5", "solution": "from typing import List\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\"\n    Inserts a number 'delimeter' between every two consecutive elements of input list `numbers`.\n\n    Args:\n        numbers (List[int]): The input list of integers.\n        delimeter (int): The number to be inserted between consecutive elements.\n\n    Returns:\n        List[int]: The modified list with the inserted number(s).\n    \"\"\"\n    # Check if the list is not empty\n    if not numbers:\n        return [delimeter] * len(numbers)\n\n    # Initialize an empty list to store the result\n    result = []\n\n    # Iterate over the input list with a step of 2\n    for i in range(len(numbers) - 1):\n        # Append the current element to the result list\n        result.append(numbers[i])\n        # Append the delimeter to the result list\n        result.append(delimeter)\n\n    # Append the remaining elements to the result list\n    result.extend(numbers[i + 1:])\n\n    return result"}
{"task_id": "HumanEval/6", "solution": "from typing import List\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    stack_level = 0\n    result = []\n    for char in paren_string:\n        if char == '(':\n            stack.append((stack_level + 1))\n        elif char == ')':\n            stack.pop()\n            stack_level -= 1\n        else:\n            stack_level += 1\n    while stack:\n        if len(stack) == 0:\n            break\n        stack_level = max(stack)\n    return [x for x in stack if x > 0]"}
{"task_id": "HumanEval/7", "solution": "from typing import List\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that contain given substring.\n\n    Args:\n        strings (List[str]): Input list of strings.\n        substring (str): The substring to filter by.\n\n    Returns:\n        List[str]: List of strings that contain the given substring.\n    \"\"\"\n    # Use list comprehension to filter the input list\n    return [string for string in strings if substring in string]\nstrings = [\"abc\", \"bacd\", \"cde\", \"array\", \"hello\", \"world\"]\nsubstring = 'a'"}
{"task_id": "HumanEval/8", "solution": "from typing import List, Tuple\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    # Calculate the sum of the numbers\n    total = sum(numbers)\n    \n    # Calculate the product of the numbers\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    # Return the sum and product as a tuple\n    return total, product"}
{"task_id": "HumanEval/9", "solution": "from typing import List\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n\n    Args:\n    numbers (List[int]): A list of integers.\n\n    Returns:\n    List[int]: A list of rolling maximum element found until given moment in the sequence.\n    \"\"\"\n    max_so_far = [0]  # Initialize with the first element as max_so_far\n    max_so_far.append(numbers[0])  # Add the first element to max_so_far\n\n    for i in range(1, len(numbers)):\n        # For each element, update max_so_far with the maximum of the current element and max_so_far\n        max_so_far.append(max_so_far[-1] if max_so_far[-1] >= numbers[i] else numbers[i])\n\n    return max_so_far"}
{"task_id": "HumanEval/10", "solution": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\""}
{"task_id": "HumanEval/11", "solution": "from typing import List\ndef string_xor(a: str, b: str) -> str:\n    \"\"\"\n    This function performs binary XOR on two input strings a and b.\n    Returns the result as a string.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = [0, 0]\n    \n    # Iterate over the characters in the input strings\n    for i in range(len(a)):\n        # If the current characters in a and b are different\n        if a[i]!= b[i]:\n            # XOR the corresponding bits\n            result[i] = '1'\n        else:\n            # If the characters are the same, the result is the same as the original input\n            result[i] = a[i]\n    \n    # Join the result into a string and return\n    return ''.join(result)"}
{"task_id": "HumanEval/12", "solution": "from typing import List, Optional\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    # If the list is empty, return None\n    if not strings:\n        return None\n    \n    # Find the length of the longest string\n    max_length = max(len(s) for s in strings)\n    \n    # Return the longest string with the maximum length\n    return max(strings, key=len)"}
{"task_id": "HumanEval/13", "solution": "import math\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    # Use the Euclidean algorithm to find the greatest common divisor\n    def gcd(a: int, b: int) -> int:\n        while b!= 0:\n            a, b = b, a % b\n        return a\n\n    # Call the gcd function with a and b as arguments\n    return gcd(a, b)"}
{"task_id": "HumanEval/14", "solution": "from typing import List\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\"\n    Return list of all prefixes from shortest to longest of the input string\n\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefix_list = []\n    for i in range(len(string) + 1):\n        prefix = string[:i]\n        if string.startswith(prefix):\n            prefix_list.append(prefix)\n    return prefix_list"}
{"task_id": "HumanEval/15", "solution": "def string_sequence(n: int) -> str:\n    \"\"\"\n    Returns a string containing space-delimited numbers starting from 0 to n inclusive.\n\n    Args:\n    n (int): The upper limit of the sequence.\n\n    Returns:\n    str: A string containing space-delimited numbers from 0 to n.\n    \"\"\"\n    # Initialize an empty list to store the numbers\n    numbers = []\n\n    # Loop through the range from 0 to n (inclusive)\n    for i in range(n + 1):\n        # Append each number to the list\n        numbers.append(str(i))\n\n    # Join the numbers into a string with spaces in between\n    result =''.join(numbers)\n\n    return result"}
{"task_id": "HumanEval/16", "solution": "def count_distinct_characters(string: str) -> int:\n    \"\"\"\n    Given a string, find out how many distinct characters (regardless of case) does it consist of\n    \"\"\"\n    # Convert the string to lowercase to remove case sensitivity\n    lower_case_string = string.lower()\n    # Use a set to store unique characters\n    unique_chars = set()\n    # Count the unique characters\n    for char in lower_case_string:\n        unique_chars.add(char)\n    # Return the number of unique characters\n    return len(unique_chars)"}
{"task_id": "HumanEval/17", "solution": "from typing import List\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\"\n    Parse musical notes and return list of integers corresponding to how many beats each note lasts.\n\n    Args:\n        music_string (str): A string representing musical notes in a special ASCII format.\n\n    Returns:\n        List[int]: A list of integers representing the number of beats each note lasts.\n    \"\"\"\n    # Define a dictionary to map note symbols to their corresponding note lengths\n    note_lengths = {\n        'o': 4,\n        '|': 2,\n        '': 1\n    }\n\n    # Initialize an empty list to store the note lengths\n    note_lengths_list = []\n\n    # Iterate over each character in the input string\n    for char in music_string:\n        # Check if the character is a note\n        if char in note_lengths:\n            # Append the note length to the list\n            note_lengths_list.append(note_lengths[char])\n\n    # Return the list of note lengths\n    return note_lengths_list\nmusic_string = 'o o|.| o| o|.|.|.|.| o o'"}
{"task_id": "HumanEval/18", "solution": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string.\n    \"\"\"\n    count = 0\n    for i in range(len(string) + 1):\n        if string[:i] == substring:\n            count += 1\n    return count"}
{"task_id": "HumanEval/19", "solution": "from typing import List"}
{"task_id": "HumanEval/20", "solution": "from typing import List, Tuple\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n    \n    Args:\n    numbers (List[float]): A list of numbers of length at least two.\n\n    Returns:\n    Tuple[float, float]: A tuple of two numbers that are the closest to each other.\n    \"\"\"\n    # Initialize minimum difference and closest pair with the first two elements\n    min_diff = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    # Iterate through the list of numbers\n    for i in range(len(numbers)):\n        # Calculate the difference between the current pair\n        diff = abs(numbers[i] - numbers[(i+1) % len(numbers)])\n\n        # If the difference is smaller than the current minimum, update the minimum difference and the closest pair\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[(i+1) % len(numbers)])\n\n    return closest_pair\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]"}
{"task_id": "HumanEval/21", "solution": "from typing import List\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\"\n    Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return [num / 3 for num in numbers]\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]"}
{"task_id": "HumanEval/22", "solution": "from typing import List, Any\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\"\n    Filter given list of any python values only for integers\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]"}
{"task_id": "HumanEval/23", "solution": "def strlen(string: str) -> int:\n    \"\"\"\n    Returns the length of the given string.\n    \"\"\"\n    return len(string)"}
{"task_id": "HumanEval/24", "solution": "def largest_divisor(n: int) -> int:\n    \"\"\"\n    For a given number n, find the largest number that divides n evenly, smaller than n.\n    \"\"\"\n    for i in range(1, n + 1):\n        if n % i == 0:\n            return i\n    return n  # If no such number is found, return n"}
{"task_id": "HumanEval/25", "solution": "from typing import List\ndef factorize(n: int) -> List[int]:\n    \"\"\"\n    Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times they appear in factorization.\n    Input number should be equal to the product of all factors\n\n    Args:\n        n (int): The number for which to find the prime factors\n\n    Returns:\n        List[int]: A list of prime factors of n\n    \"\"\"\n    factors = []\n    i = 2\n    while n > 1:\n        # Check if n is divisible by i\n        if n % i == 0:\n            # If divisible, append i to the list of factors and divide n by i\n            factors.append(i)\n            n = n // i\n        else:\n            # If not divisible, increment i to check the next number\n            i += 1\n    return factors"}
{"task_id": "HumanEval/26", "solution": "from typing import List\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    # Use a dictionary to count the occurrences of each number\n    count_dict = {}\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] = count_dict.get(num, 0) + 1\n        else:\n            count_dict[num] = 1\n    # Use list comprehension to create a new list with only unique numbers\n    return [num for num, count in count_dict.items() for num in numbers if count == 1]\nnumbers = [1, 2, 3, 2, 4]"}
{"task_id": "HumanEval/27", "solution": "def flip_case(string: str) -> str:\n    \"\"\" Flips lowercase and uppercase characters in a string.\n    Args:\n    string (str): The input string to flip.\n    Returns:\n    str: The string with both lowercase and uppercase characters.\n    \"\"\"\n    return string.swapcase()"}
{"task_id": "HumanEval/28", "solution": "from typing import List\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    '''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    result = \"\"\n    for string in strings:\n        result += string\n    return result"}
{"task_id": "HumanEval/29", "solution": "from typing import List\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\"\n    Filter an input list of strings only for ones that start with a given prefix.\n\n    Args:\n        strings (List[str]): The input list of strings.\n        prefix (str): The prefix to filter by.\n\n    Returns:\n        List[str]: A new list containing only the strings that start with the given prefix.\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]\nstrings = ['abc', 'bcd', 'cde', 'array', 'fgh', 'ghi']\nprefix = 'a'"}
{"task_id": "HumanEval/30", "solution": "def get_positive(lst):\n    \"\"\"Return only positive numbers in the list.\n    \n    Parameters:\n    lst (list): The input list to filter.\n    \n    Returns:\n    list: A new list containing only positive numbers from the input list.\n    \"\"\"\n    return [num for num in lst if num > 0]"}
{"task_id": "HumanEval/31", "solution": "def is_prime(n):\n    \"\"\"\n    Returns true if a given number is prime, false otherwise.\n\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "HumanEval/32", "solution": "import math\ndef find_zero(xs: list) -> float:\n    \"\"\"\n    Find the root of a polynomial equation f(x) = 0.\n    The root is the value of x that makes f(x) = 0.\n    This function only finds the root with the highest power, which guarantees a solution.\n    The function returns a float value.\n    \"\"\"\n    # Initialize the derivative of the polynomial\n    derivative = [0] * (len(xs) - 1)\n    # Initialize the polynomial\n    polynomial = [0] * len(xs)\n    # Iterate over the coefficients\n    for i in range(len(xs)):\n        # Calculate the power of the polynomial\n        power = 1\n        for j in range(len(xs)):\n            # Calculate the coefficient\n            coefficient = xs[j] * power\n            # Update the polynomial\n            polynomial[j] = coefficient\n        # Update the derivative\n        derivative[j] = power\n    # Find the root using the bisection method\n    while True:\n        # Calculate the midpoint of the current interval\n        midpoint = (xs[-1] - xs[-2]) / (2 * (1 - len(xs) - 2))\n        # Check if the root is found\n        if abs((xs[-1] - (midpoint)) / (1 + len(xs) - 2)) < 1e-6:\n            return midpoint\n        # Update the polynomial and derivative for the next iteration\n        polynomial = [x - midpoint for x in xs[:-1]]\n        derivative = [x - midpoint for x in xs[:-1]]"}
{"task_id": "HumanEval/33", "solution": "def sort_third(l: list) -> list:\n    \"\"\"\n    This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Initialize two pointers for the list\n    i, j = 0, 0\n\n    # Iterate through the list\n    for k in range(len(l)):\n        # If the current element is not divisible by 3, place it at the i-th index\n        if l[k] % 3!= 0:\n            l[i] = l[k]\n            i += 1\n\n    # Sort the list using the remaining elements\n    l[i:] = sorted(l[i:])\n\n    return l"}
{"task_id": "HumanEval/34", "solution": "def unique(l: list) -> list:\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(dict.fromkeys(l))"}
{"task_id": "HumanEval/35", "solution": "def max_element(lst):\n    \"\"\"\n    Returns the maximum element in the list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The maximum element in the list.\n    \"\"\"\n    return max(lst)"}
{"task_id": "HumanEval/36", "solution": "def fizz_buzz(n: int) -> int:\n    \"\"\"\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if i % 11 == 0 or i % 13 == 0:\n            count += 1\n    return count"}
{"task_id": "HumanEval/37", "solution": "def sort_even(lst):\n    \"\"\"\n    This function takes a list and returns a new list where the odd indices are the same as the original list,\n    but the even indices are sorted.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    # Use list comprehension to create a new list with odd indices as the original list and even indices as sorted list\n    return [lst[i] for i in range(len(lst)) if i % 2!= 0]"}
{"task_id": "HumanEval/38", "solution": "import re\ndef decode_cyclic(s: str) -> str:\n    \"\"\"\n    Decodes a string that was encoded by the encode_cyclic function.\n    \"\"\"\n    import re\n\n    # Split the input string into groups of three characters\n    groups = re.findall(r'\\w', s)\n\n    # If the input string is not a multiple of 3, the first group is the decoded string\n    if len(groups) % 3!= 0:\n        return groups[0]\n\n    # Cycle each group, then combine them back into a string\n    decoded_str = re.sub(r'\\w', lambda x: x[0] + x[1] + x[2], groups)\n\n    return decoded_str"}
{"task_id": "HumanEval/39", "solution": "def prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the nth Fibonacci number that is also prime.\n    \n    Args:\n    n (int): The position of the Fibonacci number to check.\n    \n    Returns:\n    int: The nth Fibonacci number that is also prime.\n    \"\"\"\n    # Initialize a list to store Fibonacci numbers\n    fib = [0, 1]\n    \n    # Calculate Fibonacci numbers until we reach the nth number\n    while len(fib) < n:\n        fib.append(fib[-1] + fib[-2])\n    \n    # Check if the number is prime\n    if all(num > 1 for num in fib if num > 1):\n        return fib[-1]\n    else:\n        return None"}
{"task_id": "HumanEval/40", "solution": "def triples_sum_to_zero(lst):\n    \"\"\"\n    This function checks if there are three distinct elements in the list that sum to zero.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if there are three distinct elements in the list that sum to zero, False otherwise.\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_nums = set(lst)\n    \n    # Check if there are three distinct elements that sum to zero\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            for k in range(j + 1, len(lst)):\n                if lst[i] + lst[j] + lst[k] == 0 and len(set(lst[i:j]) == 3):\n                    return True\n    return False"}
{"task_id": "HumanEval/41", "solution": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    This function calculates the number of collisions in a car race.\n    \n    Args:\n    n (int): The number of cars participating in the race.\n    \n    Returns:\n    int: The number of collisions that occur in the race.\n    \"\"\"\n    # Initialize the total number of collisions to 0\n    collisions = 0\n    \n    # Calculate the distance between the two sets of cars\n    distance = 1  # assuming the road is infinitely long\n    \n    # Iterate over the number of cars\n    for i in range(n):\n        # Calculate the distance the leftmost car has traveled\n        left_distance = (i + 1) * distance\n        \n        # Calculate the distance the rightmost car has traveled\n        right_distance = (n - i) * distance\n        \n        # Check for collisions\n        if left_distance < right_distance:\n            collisions += 1\n    \n    # Return the total number of collisions\n    return collisions"}
{"task_id": "HumanEval/42", "solution": "def incr_list(l: list) -> list:\n    \"\"\"\n    Return list with elements incremented by 1.\n\n    Args:\n        l (list): The input list to be incremented.\n\n    Returns:\n        list: The incremented list.\n    \"\"\"\n    return [x + 1 for x in l]"}
{"task_id": "HumanEval/43", "solution": "def pairs_sum_to_zero(l):\n    \"\"\"\n    Returns True if there are two distinct elements in the list that sum to zero, False otherwise.\n    \"\"\"\n    # Sort the list in ascending order\n    sorted_l = sorted(l)\n\n    # Iterate over pairs of elements in the list\n    for i in range(len(l) - 1):\n        # Check if the sum of the current pair is zero\n        if l[i] + l[i + 1] == 0:\n            return True\n\n    # If no pair sums to zero, return False\n    return False"}
{"task_id": "HumanEval/44", "solution": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    \"\"\"\n    if x == 0:\n        # Base case: x is 0\n        return '0'\n\n    result = ''\n    while x:\n        # Use recursion to convert x to base\n        digit = x % base\n        # Append the digit to the result\n        result = str(digit) + result\n        # Remove the digit from x\n        x = x // base\n    return result"}
{"task_id": "HumanEval/45", "solution": "def triangle_area(a, h):\n    \"\"\"\n    Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    s = (a + a + h) / 2\n    return (s * h) / 2"}
{"task_id": "HumanEval/46", "solution": "def fib4(n: int) -> int:\n    \"\"\"\n    Compute the n-th element of the Fibonacci4 number sequence.\n\n    The Fibonacci4 sequence is a sequence similar to the Fibonacci sequence, but with a different starting values.\n\n    Args:\n    n (int): The position of the element to compute.\n\n    Returns:\n    int: The n-th element of the Fibonacci4 sequence.\n\n    Raises:\n    TypeError: If n is not an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n\n    # Initialize the first three Fibonacci numbers\n    a, b, c = 0, 1, 1\n\n    # Compute the n-th Fibonacci number\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n\n    return c"}
{"task_id": "HumanEval/47", "solution": "import statistics\ndef median(lst):\n    \"\"\"\n    Return the median of the elements in the list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        float: The median of the elements in the list.\n\n    Raises:\n        ValueError: If the input list is empty.\n\n    Examples:\n        >>> median([3, 1, 2, 4, 5])\n        3\n        >>> median([-10, 4, 6, 1000, 10, 20])\n        15.0\n    \"\"\"\n    # Check if the list is empty\n    if not lst:\n        raise ValueError(\"Input list is empty\")\n\n    # Use the statistics module to find the median\n    return statistics.median(lst)"}
{"task_id": "HumanEval/48", "solution": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    # Remove spaces and convert to lowercase\n    text = text.replace(\" \", \"\").lower()\n    # Compare characters from start and end of string\n    return text == text[::-1]"}
{"task_id": "HumanEval/49", "solution": "def modp(n: int, p: int) -> int:\n    \"\"\"\n    Return 2^n modulo p (be aware of numerics).\n    \n    Parameters:\n    n (int): The power of 2.\n    p (int): The modulus.\n    \"\"\"\n    # Use the built-in pow function to calculate 2^n modulo p\n    result = pow(2, n, p)\n    return result"}
{"task_id": "HumanEval/50", "solution": "def encode_shift(s: str) -> str:\n    \"\"\"\n    Encodes a string by shifting every character by 5 in the alphabet.\n\n    Args:\n    s (str): Input string to be encoded.\n\n    Returns:\n    str: Encoded string.\n    \"\"\""}
{"task_id": "HumanEval/51", "solution": "def remove_vowels(text):\n    \"\"\"\n    Remove all vowels from a given string.\n    \n    Parameters:\n    text (str): The input string.\n    \n    Returns:\n    str: The input string without vowels.\n    \"\"\"\n    vowels = set('aeiou')\n    return ''.join([char for char in text if char not in vowels])"}
{"task_id": "HumanEval/52", "solution": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"\n    Return True if all numbers in the list l are below threshold t.\n\n    Args:\n        l (list): A list of numbers.\n        t (int): The threshold value.\n\n    Returns:\n        bool: True if all numbers in the list are below threshold, False otherwise.\n    \"\"\"\n    return all(num < t for num in l)"}
{"task_id": "HumanEval/53", "solution": "def add(x: int, y: int) -> int:\n    \"\"\"\n    Adds two numbers x and y.\n    \n    Args:\n    x (int): The first number to add.\n    y (int): The second number to add.\n    Returns:\n    int: The sum of x and y.\n    \"\"\"\n    return x + y"}
{"task_id": "HumanEval/54", "solution": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n\n    Args:\n        s0 (str): First word.\n        s1 (str): Second word.\n\n    Returns:\n        bool: True if words have the same characters, False otherwise.\n\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return sorted(s0) == sorted(s1)"}
{"task_id": "HumanEval/55", "solution": "def fibonacci(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    # Base cases\n    if n <= 1:\n        return 1\n    elif n == 2:\n        return 1\n    # Recursive case\n    else:\n        a, b = 1, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n\n# Test cases"}
{"task_id": "HumanEval/56", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Checks if every opening bracket has a corresponding closing bracket.\n\n    Args:\n        brackets (str): A string of \"<\" and \">\".\n\n    Returns:\n        bool: True if the brackets are balanced, False otherwise.\n    \"\"\"\n    stack = []\n    bracket_map = {\")\": \"(\", \"(\": \")\"}\n\n    for char in brackets:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop()!= bracket_map[char]:\n                return False\n    return not bool(stack)"}
{"task_id": "HumanEval/57", "solution": "def monotonic(lst):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\"\"\"\n    n = len(lst)\n    for i in range(n - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"}
{"task_id": "HumanEval/58", "solution": "from typing import List\ndef common(l1: List[int], l2: List[int]) -> List[int]:\n    \"\"\"\n    Return a sorted list of unique elements common to both input lists.\n    \n    Args:\n    l1 (List[int]): First list of integers.\n    l2 (List[int]): Second list of integers.\n    \n    Returns:\n    List[int]: A sorted list of unique elements common to both input lists.\n    \"\"\"\n    # Convert the input lists to sets to remove duplicates and improve lookup efficiency\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Use set intersection to find common elements\n    common_elements = list(set1 & set2)\n    \n    # Convert the list of common elements back to a list\n    result = [element for element in common_elements]\n    \n    return result"}
{"task_id": "HumanEval/59", "solution": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    # Handle edge case: n = 1\n    if n == 1:\n        return 1\n\n    # Initialize the largest factor with the first prime number (2)\n    largest_factor = 2\n\n    # Start checking from 3\n    for i in range(3, int(n ** 0.5) + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # If i is a factor and it's the largest factor so far, update the largest factor\n            if i > largest_factor and i > n / i:\n                largest_factor = i\n\n    # If no factors are found, return the largest factor\n    return largest_factor"}
{"task_id": "HumanEval/60", "solution": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    Sums numbers from 1 to n.\n    \n    Args:\n    n (int): The upper limit of the sum.\n    \n    Returns:\n    int: The sum of numbers from 1 to n.\n    \"\"\"\n    if n == 0:\n        # Base case: sum of 0 is 0\n        return 0\n    \n    # Recursive case: sum of n is 1 + sum of (n-1)\n    else:\n        # Calculate the sum of (n-1) using recursion\n        return n + sum_to_n(n-1)"}
{"task_id": "HumanEval/61", "solution": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Checks if the input string has correct bracketing.\n\n    Args:\n        brackets (str): A string containing parentheses.\n\n    Returns:\n        bool: True if the brackets are correct, False otherwise.\n    \"\"\"\n    stack = []\n    opening_brackets = []\n    for char in brackets:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack or not is_valid_bracket(opening_brackets.pop()):\n                return False\n    return not stack\ndef is_valid_bracket(opening_brackets: list) -> bool:\n    \"\"\"\n    Checks if the opening brackets match the corresponding closing brackets.\n\n    Args:\n        opening_brackets (list): A list of opening brackets.\n\n    Returns:\n        bool: True if the brackets are valid, False otherwise.\n    \"\"\"\n    stack = []\n    for opening_bracket in opening_brackets:\n        if not stack or not is_matching_bracket(opening_bracket, closing_bracket):\n            return False\n    return not stack\ndef is_matching_bracket(opening_bracket: str, closing_bracket: str) -> bool:\n    \"\"\"\n    Checks if the opening bracket matches the closing bracket.\n\n    Args:\n        opening_bracket (str): The opening bracket.\n        closing_bracket (str): The closing bracket.\n\n    Returns:\n        bool: True if the brackets match, False otherwise.\n    \"\"\"\n    if not (opening_bracket == '(' and closing_bracket == ')'):\n        return False\n    if not (opening_bracket == ')' and closing_bracket == ')'):\n        return False\n    return (opening_bracket == '(' and closing_bracket == ')')"}
{"task_id": "HumanEval/62", "solution": "import numpy as np\ndef derivative(xs: list):\n    \"\"\"\n    Compute the derivative of a polynomial represented by the coefficients in xs.\n\n    Parameters:\n    xs (list): coefficients of the polynomial in descending order of powers.\n\n    Returns:\n    list: coefficients of the derivative polynomial.\n    \"\"\"\n    # Convert the input list to a NumPy array\n    xs = np.array(xs)\n\n    # Compute the derivative using finite differences\n    derivative = [0] + [i * x for i, x in enumerate(reversed(xs))]\n\n    return derivative"}
{"task_id": "HumanEval/63", "solution": "def fibfib(n: int) -> int:\n    \"\"\"\n    The Fibonacci number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(3, n + 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "HumanEval/64", "solution": "import re\ndef vowels_count(s):\n    \"\"\"\n    Returns the number of vowels in the given string.\n    Vowels are 'a', 'e', 'i', 'o', 'u'.\n    'y' is considered a vowel when it is at the end of the word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    # Define the vowels\n    vowels = 'aeiouy'\n\n    # Use regular expression to find all occurrences of vowels\n    # The regular expression pattern '\\b[auiy]\\w*\\b' matches\n    # any word that ends with a vowel and is not a multi-word\n    pattern = r'\\b[auiy]\\w*\\b'\n\n    # Use re.findall to find all matches\n    matches = re.findall(pattern, s)\n\n    # Return the count of matches\n    return len(matches)"}
{"task_id": "HumanEval/65", "solution": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string. If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    digits = [int(d) for d in str(x)]\n    shift = shift % len(digits)"}
{"task_id": "HumanEval/66", "solution": "def digitSum(s):\n    \"\"\"\n    Returns the sum of the ASCII codes of the upper-case characters in the input string.\n    \n    Args:\n    s (str): The input string.\n    \n    Returns:\n    int: The sum of the ASCII codes of the upper-case characters.\n    \"\"\"\n    return sum(ord(char) for char in s if char.isupper())"}
{"task_id": "HumanEval/67", "solution": "def fruit_distribution(s, n):\n    \"\"\"\n    This function takes a string and an integer as input, and returns the number of mango fruits in the basket.\n\n    Args:\n    s (str): A string that represents the number of apples and oranges.\n    n (int): An integer that represents the total number of fruits in the basket.\n\n    Returns:\n    int: The number of mango fruits in the basket.\n    \"\"\"\n    # Split the input string into two parts: apples and oranges\n    apples, oranges = map(int, s.split(' and '))\n    \n    # Calculate the total number of fruits\n    total_fruits = apples + oranges\n    \n    # Subtract the number of apples and oranges from the total\n    mango_fruits = total_fruits - apples - oranges\n    \n    return mango_fruits"}
{"task_id": "HumanEval/68", "solution": "def find_smallest_even(arr):\n    \"\"\"\n    Find the node with the smallest even value in the array.\n    \n    Args:\n    arr (list): A list of integers representing a branch of a tree.\n    \n    Returns:\n    list: A list containing the smallest even value and its index.\n    \"\"\"\n    # Initialize the smallest even value and its index\n    smallest_even = float('inf')\n    smallest_index = -1\n\n    # Iterate through the array\n    for i, value in enumerate(arr):\n        # Check if the value is even\n        if value % 2 == 0:\n            # Update the smallest even value and its index if necessary\n            if value < smallest_even:\n                smallest_even = value\n                smallest_index = i\n\n    # Return the smallest even value and its index\n    return [smallest_even, smallest_index]\n\n# Test cases"}
{"task_id": "HumanEval/69", "solution": "def search(lst):\n    \"\"\"\n    Returns the greatest integer greater than zero with a frequency >= the integer itself.\n\n    Args:\n        lst (list): A non-empty list of positive integers.\n\n    Returns:\n        int: The greatest integer greater than zero with a frequency >= the integer itself, or -1 if no such value exists.\n    \"\"\"\n    # Create a dictionary to count the frequency of each integer\n    freq_dict = {}\n    for num in lst:\n        freq_dict[num] = lst.count(num)\n\n    # Find the greatest integer with a frequency >= the integer itself\n    for num in sorted(freq_dict.keys()):\n        if freq_dict[num] >= num:\n            return num\n\n    # If no such value exists, return -1\n    return -1"}
{"task_id": "HumanEval/70", "solution": "def strange_sort_list(lst):\n    \"\"\"\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    \"\"\"\n    # Use Python's built-in sorted function to sort the list\n    return sorted(lst)"}
{"task_id": "HumanEval/71", "solution": "import math\ndef triangle_area(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    \"\"\"\n    # Check if the sides form a valid triangle\n    if a + b > c and b + c > a and c + a > b:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # If the sides do not form a valid triangle, return -1\n        return -1"}
{"task_id": "HumanEval/72", "solution": "def will_it_fly(q, w):\n    \"\"\"\n    Returns True if the object q will fly, and False otherwise.\n\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n    Parameters:\n    q (list): The object to check.\n    w (int): The maximum possible weight.\n\n    Returns:\n    bool: Whether the object q will fly.\n    \"\"\"\n    def is_palindromic(lst):\n        \"\"\"\n        Returns True if the list is palindromic, False otherwise.\n        \"\"\"\n        return lst == lst[::-1]\n\n    def is_balanced(lst):\n        \"\"\"\n        Returns True if the list is balanced, False otherwise.\n        \"\"\"\n        return sum(lst) <= w\n\n    return is_palindromic(q) and is_balanced(q)"}
{"task_id": "HumanEval/73", "solution": "def smallest_change(arr):\n    \"\"\"\n    Given an array of integers, find the minimum number of elements that need to be changed\n    to make the array palindromic.\n\n    Args:\n        arr (list): The input array of integers.\n\n    Returns:\n        int: The minimum number of elements that need to be changed to make the array palindromic.\n\n    Example:\n        >>> smallest_change([1,2, 3, 4, 3, 2, 2])\n        1\n        >>> smallest_change([1, 2, 3, 4, 3, 2, 1])\n        0\n        >>> smallest_change([1, 2, 3, 2, 1])\n        0\n    \"\"\"\n    n = len(arr)\n    changes = 0\n\n    # Iterate through the array from left to right\n    for i in range(n - 1):\n        # Check if the current element is different from the corresponding element from the end\n        if arr[i]!= arr[-i]:\n            changes += 1\n\n    return changes"}
{"task_id": "HumanEval/74", "solution": "def total_match(lst1, lst2):\n    \"\"\"\n    Returns a list with the number of characters in the first list that are less than the second list.\n    If the lists have the same length, returns the first list.\n\n    Args:\n    lst1 (list): The first list of strings.\n    lst2 (list): The second list of strings.\n\n    Returns:\n    list: A list of strings with the number of characters in the first list that are less than the second list.\n    \"\"\"\n    # Use list comprehension to count the characters in each list\n    less_than_lst = [len(s) for s in zip(*lst1)]\n    # Use the built-in sorted function to sort the list in descending order\n    less_than_lst = sorted(less_than_lst, reverse=True)\n    # Return the first list with the characters less than the second list\n    return [s for s, l in zip(lst1, less_than_lst) if s < l]"}
{"task_id": "HumanEval/75", "solution": "def is_multiply_prime(n):\n    \"\"\"\n    Checks if a number is the multiplication of 3 prime numbers.\n\n    Args:\n    n (int): The input number to check.\n\n    Returns:\n    bool: True if the number is the product of 3 prime numbers, False otherwise.\n    \"\"\"\n    def is_prime(num):\n        \"\"\"\n        Checks if a number is prime.\n\n        Args:\n        num (int): The input number to check.\n\n        Returns:\n        bool: True if the number is prime, False otherwise.\n        \"\"\"\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    # Check if n is the product of 3 prime numbers\n    for i in range(1, int(n ** 0.5) + 1):\n        if n % i == 0 and is_prime(i) and is_prime(n // i):\n            return True\n    return False"}
{"task_id": "HumanEval/76", "solution": "import math\ndef is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n, False otherwise.\n    \n    A simple power of n is a number that can be expressed as x = n^x.\n    \"\"\"\n    if n == 1:\n        # Base case: if x is 1, x is a power of 1\n        return x == 1\n    elif x == n:\n        # Base case: if x is n, x is a power of n\n        return x == n\n    else:\n        # Recursive case: if x is not 1 or n, check if x can be expressed as n^x\n        return (x == n ** int(x))"}
{"task_id": "HumanEval/77", "solution": "def is_cube(a):\n    \"\"\"\n    Checks if a number is a perfect cube.\n\n    Args:\n    a (int): The number to check.\n\n    Returns:\n    bool: True if the number is a perfect cube, False otherwise.\n    \"\"\"\n    # Calculate the cube root\n    cube_root = round(a ** (1 / 3))\n\n    # Check if the cube root is an integer\n    if cube_root ** 3 == a:\n        return True\n    else:\n        return False\n\n# Test cases"}
{"task_id": "HumanEval/78", "solution": "def hex_key(num):\n    \"\"\"\n    This function counts the number of hexadecimal digits that are prime numbers.\n    \n    Parameters:\n    num (str): A string representing a hexadecimal number.\n    \n    Returns:\n    int: The number of hexadecimal digits that are prime numbers.\n    \"\"\"\n    def is_prime(n):\n        \"\"\"Checks if a number is prime.\"\"\"\n        if n <= 1:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0 and n > 2:\n            return False\n        for i in range(3, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    # Convert the input string to uppercase\n    num = num.upper()\n\n    # Initialize counter for prime digits\n    prime_count = 0\n\n    # Iterate over each character in the input string\n    for char in num:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Check if the digit is prime\n            if is_prime(int(char)):\n                prime_count += 1\n\n    return prime_count"}
{"task_id": "HumanEval/79", "solution": "def decimal_to_binary(decimal):\n    \"\"\"\n    Converts a decimal number to binary format.\n\n    Args:\n    decimal (int): The decimal number to be converted.\n\n    Returns:\n    str: The binary representation of the decimal number, prefixed with \"db\" and followed by an extra \"db\".\n    \"\"\"\n    # Convert decimal to binary and remove the 'db' prefix\n    binary = bin(decimal)[2:]\n    # Add the 'db' prefix\n    return \"db\" + binary"}
{"task_id": "HumanEval/80", "solution": "def is_happy(s):\n    \"\"\"Check if a string is happy.\"\"\"\n    def helper(s):\n        if len(s) < 3:\n            return False\n        seen = set()\n        for i in range(len(s)):\n            if s[i] in seen:\n                return False\n            seen.add(s[i])\n        return True\n    return helper(s)"}
{"task_id": "HumanEval/81", "solution": "def numerical_letter_grade(grades):\n    \"\"\"\n    This function takes a list of grades and returns a list of corresponding letter grades.\n\n    Args:\n        grades (list): A list of grades.\n\n    Returns:\n        list: A list of letter grades.\n\n    Example:\n        >>> numerical_letter_grade([4.0, 3, 1.7, 2, 3.5])\n        ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n    # Define a dictionary to map GPA ranges to letter grades\n    grade_map = {\n        (3.7, 3.3): 'A',\n        (3.3, 2.7): 'A-',\n        (2.7, 2.0): 'B',\n        (2.0, 1.7): 'B-',\n        (1.7, 1.0): 'C-',\n        (1.0, 0.0): 'D+',\n        (0.0, 0.0): 'E'\n    }\n\n    # Use list comprehension to map GPA to letter grade\n    return [grade_map.get(gpa, 'Unknown') for gpa in grades]"}
{"task_id": "HumanEval/82", "solution": "def prime_length(string):\n    \"\"\"Return True if the length of the string is a prime number, False otherwise.\"\"\"\n    return len(string) <= 2"}
{"task_id": "HumanEval/83", "solution": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n\n    Args:\n    n (int): A positive integer.\n\n    Returns:\n    int: The count of n-digit positive integers that start or end with 1.\n    \"\"\"\n    # Calculate the number of 1's in the first and last positions\n    first_pos = 1\n    last_pos = 10 ** (n - 1)\n    # Calculate the number of n-digit numbers that start with 1\n    start_with_1 = 1 * (10 ** (n - 1))\n    # Calculate the number of n-digit numbers that end with 1\n    end_with_1 = 1 * (10 ** (n - 1))\n    # Return the total count\n    return start_with_1 + end_with_1"}
{"task_id": "HumanEval/84", "solution": "def sum_binary(N):\n    \"\"\"\n    Calculate the sum of digits of a given integer N in binary.\n\n    Args:\n    N (int): A positive integer.\n\n    Returns:\n    str: A string of binary digits representing the sum of N's digits.\n    \"\"\"\n    # Convert N to binary and remove the '0b' prefix\n    bin_N = bin(N)[2:]\n    # Initialize the sum\n    total = 0\n    # Loop through each character in the binary string\n    for digit in bin_N:\n        # Convert each character back to an integer and add to the total\n        total += int(digit)\n    # Convert the total back to a string and return\n    return bin(int(str(total), 2))\n\n# Test the function"}
{"task_id": "HumanEval/85", "solution": "def add(lst):\n    \"\"\"\n    Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Args:\n        lst (list): A non-empty list of integers.\n\n    Returns:\n        int: The sum of the even elements at odd indices.\n\n    Examples:\n        >>> add([4, 2, 6, 7])\n        2\n    \"\"\"\n    even_at_odd_indices = [lst[1], lst[2], lst[3]]\n    return sum(even_at_odd_indices)"}
{"task_id": "HumanEval/86", "solution": "def anti_shuffle(s):\n    \"\"\"\n    Returns an ordered version of the input string where all words are in ascending order of ASCII values.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The ordered version of the input string.\n    \"\"\"\n    # Split the input string into words\n    words = s.split()\n\n    # Sort the words based on ASCII values\n    sorted_words = sorted(words)\n\n    # Join the sorted words back into a string\n    return ''.join(sorted_words)"}
{"task_id": "HumanEval/87", "solution": "def get_row(lst, x):\n    \"\"\"\n    Returns a list of tuples, each containing a coordinate (row, column) \n    where the value in the row is equal to x and the column is greater than x.\n\n    Args:\n    lst (list): A 2-dimensional data structure.\n    x (int): The value to search for.\n\n    Returns:\n    list: A list of tuples, each containing a coordinate (row, column) \n          where the value in the row is equal to x and the column is greater than x.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n\n    # Sort the list by rows in ascending order\n    lst.sort(key=lambda row: row[0])\n\n    # Iterate over the sorted list\n    for row in lst:\n        # Check if the current row is greater than x\n        if row[0] > x:\n            # Append the coordinate to the result list\n            result.append((row[0], row[0]))\n\n    # Sort the result list by columns in descending order\n    result.sort(key=lambda row: row[1], reverse=True)\n\n    return result"}
{"task_id": "HumanEval/88", "solution": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    # Create a copy of the input array\n    array = array.copy()\n\n    # Use built-in sorted function to sort the array\n    sorted_array = sorted(array)\n\n    # Check if the sum of the first and last elements is odd\n    if array[0] + array[-1] % 2!= 0:\n        # Sort in ascending order\n        sorted_array = sorted(array)\n    else:\n        # Sort in descending order\n        sorted_array = sorted(array, reverse=True)\n\n    return sorted_array"}
{"task_id": "HumanEval/89", "solution": "def encrypt(s):\n    \"\"\"\n    Encrypts a string by shifting each character two positions down in the alphabet.\n\n    Args:\n        s (str): The input string to be encrypted.\n\n    Returns:\n        str: The encrypted string.\n    \"\"\"\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = ''\n    for i, char in enumerate(s):\n        if char.isalpha():\n            shift = (ord(char) - ord('a') + 2) % 26\n            result += alphabet[(alphabet.index(char) + shift)]\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/90", "solution": "def next_smallest(lst):\n    \"\"\"\n    Returns the 2nd smallest element of the list.\n    If no such element exists, returns None.\n    \n    Parameters:\n    lst (list): The input list of integers.\n    \n    Returns:\n    int: The 2nd smallest element of the list, or None if not found.\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    return sorted(lst)[1]"}
{"task_id": "HumanEval/91", "solution": "def is_bored(S):\n    \"\"\"\n    Counts the number of sentences in a given string that start with 'I'\n    and have a period or exclamation mark as the first character.\n\n    Args:\n        S (str): The input string.\n\n    Returns:\n        int: The number of bored sentences.\n\n    Example:\n        >>> is_bored(\"Hello world\")\n        0\n        >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n        1\n    \"\"\"\n    # Split the input string into sentences\n    sentences = S.split('.')\n\n    # Filter out the sentences that start with 'I' and have a period or exclamation mark\n    bored_sentences = [sentence for sentence in sentences if sentence.startswith('I') and (sentence[0] in ['.', '!'])]\n\n    # Return the count of bored sentences\n    return len(bored_sentences)"}
{"task_id": "HumanEval/92", "solution": "def any_int(x, y, z):\n    \"\"\"\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Parameters:\n    x (int): The first number to compare.\n    y (int): The second number to compare.\n    z (int): The third number to compare.\n    \n    Returns:\n    bool: True if the conditions are met, False otherwise.\n    \"\"\"\n    return (x == (y + z) or z == (x + y))"}
{"task_id": "HumanEval/93", "solution": "def encode(message):\n    \"\"\"\n    Encodes a message by swapping case and shifting vowels two places forward in the alphabet.\n    \n    Args:\n    message (str): The input message to be encoded.\n\n    Returns:\n    str: The encoded message.\n    \"\"\"\n    result = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.lower() in 'aeiou':\n                if char.lower() == 'a':\n                    result += 'b'\n                elif char.lower() == 'e':\n                    result += 'a'\n                elif char.lower() == 'i':\n                    result += 'c'\n                elif char.lower() == 'o':\n                    result += 'd'\n                elif char.lower() == 'u':\n                    result += 'e'\n            else:\n                result += char\n    return result"}
{"task_id": "HumanEval/94", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef sum_of_digits(n):\n    \"\"\"Calculate the sum of digits of a number.\"\"\""}
{"task_id": "HumanEval/95", "solution": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower or upper case, \n    else return False. The function returns False is the given dictionary is empty.\n\n    Args:\n        dict (dict): The input dictionary to be checked.\n\n    Returns:\n        bool: Whether the dictionary is in the desired case.\n    \"\"\"\n    # Initialize a flag to track the number of non-string keys\n    all_lower = True\n    all_upper = True\n\n    # Iterate over each key-value pair in the dictionary\n    for key, value in dict.items():\n        # If the value is not a string, update the flag and break\n        if not isinstance(value, str):\n            all_lower = False\n            break\n        # If the key is not in lower case, update the flag and break\n        if not key.lower() in ['a', 'A']:\n            all_lower = False\n            break\n\n    # Return True if all keys are in the desired case, else return False\n    return all([all_lower, all_upper])"}
{"task_id": "HumanEval/96", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef count_up_to(n):\n    \"\"\"Return a list of the first n prime numbers less than n.\"\"\"\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes"}
{"task_id": "HumanEval/97", "solution": "def multiply(a, b):\n    \"\"\"Return the product of the unit digits of a and b\"\"\"\n    # Convert numbers to strings to access individual digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Initialize result variable\n    result = \"\"\n    \n    # Iterate over each character in the strings"}
{"task_id": "HumanEval/98", "solution": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    vowels = 'AEIOUaeiou'\n    count = 0\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char in vowels:\n            count += 1\n    return count"}
{"task_id": "HumanEval/99", "solution": "def closest_integer(value):\n    \"\"\"\n    Returns the closest integer to a given value.\n\n    If the number is equidistant from two integers, rounds it away from zero.\n\n    Args:\n    value (str): A string representing a number.\n\n    Returns:\n    int: The closest integer to the given value.\n    \"\"\"\n    # Convert the input string to a float\n    num = float(value)\n\n    # Calculate the absolute difference between the number and the nearest integer\n    lower = int(num)\n    upper = int(num)\n\n    # Round the difference away from zero\n    if abs(num - lower) > abs(num - upper):\n        return lower\n    else:\n        return upper"}
{"task_id": "HumanEval/100", "solution": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n    - the next odd number if n is odd.\n    - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n    \"\"\"\n    # Initialize an empty list to store the pile\n    pile = [0] * (n + 1)\n    \n    # Loop through each level\n    for i in range(1, n + 1):\n        # If the number is odd, add the next odd number to the pile\n        if i % 2!= 0:\n            pile[i] = i + 1\n        # If the number is even, add the next even number to the pile\n        else:\n            pile[i] = 2 * (i // 2)\n    return pile"}
{"task_id": "HumanEval/101", "solution": "def words_string(s):\n    \"\"\"\n    Split a string of words separated by commas or spaces into a list of words.\n\n    Args:\n        s (str): The input string of words.\n\n    Returns:\n        list: A list of words.\n    \"\"\"\n    # Split the input string into words using comma as separator\n    words = s.split(',')\n\n    # Remove leading and trailing whitespaces from each word\n    words = [word.strip() for word in words]\n\n    return words"}
{"task_id": "HumanEval/102", "solution": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function returns -1.\n\n    Args:\n    x (int): The lower bound of the range (inclusive).\n    y (int): The upper bound of the range (inclusive).\n\n    Returns:\n    int: The biggest even integer number in the range [x, y]. If there's no such number, returns -1.\n    \"\"\"\n    if x > y:\n        return -1\n    mid = (x + y + 1) // 2\n    if mid % 2 == 0 and mid > x:\n        return mid\n    return -1"}
{"task_id": "HumanEval/103", "solution": "def rounded_avg(n, m):\n    \"\"\"\n    Compute the average of the integers from n through m, round to the nearest integer, and convert to binary.\n\n    Args:\n    n (int): The starting integer.\n    m (int): The ending integer.\n\n    Returns:\n    str: The binary representation of the rounded average, or -1 if n is greater than m.\n    \"\"\"\n    if n > m:\n        return -1  # If n is greater than m, return -1\n\n    # Calculate the average\n    avg = (n + m) // 2\n\n    # Round to the nearest integer\n    rounded_avg = int(str(avg), 2)\n\n    # Convert to binary\n    binary = bin(rounded_avg)[2:]  # Remove the '0b' prefix\n\n    return binary"}
{"task_id": "HumanEval/104", "solution": "def unique_digits(x):\n    \"\"\"Given a list of positive integers, return a sorted list of all elements that hasn't any even digit.\n\n    Args:\n    x (list): A list of positive integers.\n\n    Returns:\n    list: A sorted list of unique numbers that have no even digits.\n\n    Example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    # Convert the list to a set to remove duplicates\n    unique_nums = set()\n    for num in x:\n        # Convert the number to a string to check for even digits\n        str_num = str(num)\n        if int(str_num[0] % 2)!= 0:\n            # Add the number to the set\n            unique_nums.add(num)\n    # Convert the set back to a list and sort it\n    return sorted(list(unique_nums))"}
{"task_id": "HumanEval/105", "solution": "def sort_and_replace(arr):\n    \"\"\"\n    Sorts the input array by digit and replaces each digit with its corresponding name.\n\n    Args:\n        arr (list): The input array of integers.\n\n    Returns:\n        list: The sorted and replaced array.\n    \"\"\"\n    # Convert each number to string to process digits\n    str_arr = [str(num) for num in arr]\n    # Sort the array by digit\n    sorted_arr = sorted(str_arr)\n    # Reverse the array\n    reversed_arr = sorted[::-1]\n    # Replace each digit with its corresponding name"}
{"task_id": "HumanEval/106", "solution": "import math\ndef f(n):\n    \"\"\"\n    This function generates a list of numbers based on the problem description.\n    \n    Args:\n    n (int): The size of the list to be generated.\n    \n    Returns:\n    list: A list of numbers where the value at index i is the factorial of i if i is even, otherwise it is the sum of numbers from 1 to i.\n    \"\"\"\n    result = [0] * n\n    for i in range(n):\n        if i % 2 == 0:\n            # Calculate the factorial of i using the math library\n            result[i] = math.factorial(i)\n        else:\n            # Calculate the sum of numbers from 1 to i\n            result[i] = sum(range(1, i + 1))\n    return result"}
{"task_id": "HumanEval/107", "solution": "def even_odd_palindrome(n):\n    \"\"\"\n    Returns a tuple of the number of even and odd integer palindromes within the range [1, n].\n    \"\"\"\n    count_even = sum(1 for i in range(1, n+1) if i % 2 == 0)\n    count_odd = sum(1 for i in range(1, n+1) if i % 2!= 0)\n    return (count_even, count_odd)"}
{"task_id": "HumanEval/108", "solution": "def count_nums(arr):\n    \"\"\"\n    Returns the number of elements in the array that have a sum of digits > 0.\n    If a number is negative, its first signed digit is considered.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The number of elements with a sum of digits > 0.\n    \"\"\"\n    count = 0\n    for num in arr:\n        sign = -1 if num < 0 else 1"}
{"task_id": "HumanEval/109", "solution": "def move_one_ball(arr):\n    \"\"\"\n    Determines if it is possible to get a sorted array from an unsorted array\n    by performing a series of right shift operations.\n\n    Args:\n    arr (list): The input array of integers.\n\n    Returns:\n    bool: True if a sorted array can be obtained, False otherwise.\n    \"\"\"\n    if len(arr) == 0:  # If the array is empty, return True\n        return True\n\n    # Initialize a counter to track the number of non-decreasing moves\n    non_decreasing_moves = 0\n\n    # Iterate through the array from the end to the beginning\n    for i in range(len(arr) - 1, -1, -1):\n        # If the current element is less than the next element, increment the counter\n        if arr[i] < arr[i + 1]:\n            non_decreasing_moves += 1\n\n    # If no non-decreasing moves are needed, return True\n    if non_decreasing_moves == 0:\n        return True\n\n    # If at least one non-decreasing move is needed, return False\n    return non_decreasing_moves > 0"}
{"task_id": "HumanEval/110", "solution": "def exchange(lst1, lst2):\n    \"\"\"\n    Determines whether it is possible to exchange elements between two lists to make all elements of lst1 even.\n\n    Args:\n    lst1 (list): The list of numbers to be made even.\n    lst2 (list): The list of numbers to exchange with.\n\n    Returns:\n    str: \"YES\" if the exchange is possible, \"NO\" otherwise.\n    \"\"\"\n    # Convert both lists to sets for efficient lookups\n    set1 = set(lst1)\n    set2 = set(lst2)\n\n    # Check if all elements in lst2 are in lst1\n    if not all(x in set1 for x in lst2):\n        return \"NO\"\n\n    # Check if all elements in lst1 are in set2\n    return all(x in set2 for x in lst1)"}
{"task_id": "HumanEval/111", "solution": "def histogram(test):\n    \"\"\"\n    Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n\n    Args:\n        test (str): A string representing a space separated lowercase letters.\n\n    Returns:\n        dict: A dictionary of the letter with the most repetition and containing the corresponding count.\n    \"\"\"\n    # Split the input string into a list of letters\n    letters = test.split()\n\n    # Count the occurrence of each letter\n    counts = {}\n    for letter in letters:\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n\n    # Return the dictionary of counts\n    return counts"}
{"task_id": "HumanEval/112", "solution": "def reverse_delete(s, c):\n    \"\"\"\n    Reverses the input string `s` and removes all characters equal to any character in `c`.\n    Returns a tuple containing the reversed string and a boolean indicating whether the resulting string is a palindrome.\n\n    Args:\n    s (str): The original string.\n    c (str): The character to be removed from the original string.\n\n    Returns:\n    tuple: A tuple containing the reversed string and a boolean indicating whether the resulting string is a palindrome.\n    \"\"\"\n    # Create a set of characters to be removed\n    chars_to_remove = set(c)\n\n    # Reverse the string\n    reversed_s = \"\"\n\n    # Iterate over the input string\n    for char in s:\n        # Check if the character is in the set of characters to be removed\n        if char in chars_to_remove:\n            # Remove the character from the string\n            s = s.replace(char, \"\", 1)\n        else:\n            # If not, add the character to the reversed string\n            reversed_s += char\n\n    # Check if the resulting string is a palindrome\n    is_palindrome = s == reversed_s\n\n    return reversed_s, is_palindrome\ns = \"abcde\"\nc = \"ae\""}
{"task_id": "HumanEval/113", "solution": "def odd_count(lst):"}
{"task_id": "HumanEval/114", "solution": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    \"\"\"\n    min_sum = float('inf')\n    current_sum = 0\n    for i in range(len(nums)):\n        current_sum = 0\n        for j in range(i, len(nums)):\n            current_sum += nums[j]\n            if current_sum < min_sum:\n                min_sum = current_sum\n    return min_sum"}
{"task_id": "HumanEval/115", "solution": "import math\ndef max_fill(grid, capacity):\n    \"\"\"\n    This function calculates the number of times buckets need to be lowered to empty wells in a grid.\n    \n    Args:\n    grid (list of lists): A 2D list representing wells with 1s indicating water and 0s indicating empty wells.\n    capacity (int): The capacity of each bucket.\n    \n    Returns:\n    int: The number of times buckets need to be lowered.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    fill_count = 0\n\n    # Initialize a set to keep track of filled wells\n    filled_wells = set()\n\n    # Iterate over each row in the grid\n    for row in range(rows):\n        # Initialize a set to keep track of wells that are currently being filled\n        current_wells = set()\n\n        # Iterate over each well in the current row\n        for j, can_fill in enumerate(grid[row]):\n            # If the current well is filled, increment fill count\n            if can_fill == 1:\n                fill_count += 1\n                # If the current well is filled and it's not the last well in the row, \n                # mark it as filled and add it to the current wells set\n                if j!= cols - 1:\n                    current_wells.add(j)\n            # If the current well is empty, try to fill it with the current bucket\n                while can_fill > 0:\n                    can_fill -= 1\n                    # If the current well is filled, increment fill count and mark it as filled\n                    fill_count += 1\n                    # If the current well is not empty, add it to the current wells set\n                    if can_fill == 1:\n                        fill_count += 1\n                        current_wells.add(j)\n                    # If the current well is empty, return the fill count\n                    break\n            # If the current well is empty, return the fill count\n            if can_fill == 0:\n                return fill_count\n\n    # If no wells were filled, return the fill count\n    return fill_count\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\ncapacity = 1"}
{"task_id": "HumanEval/116", "solution": "def sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers according to the number of ones in their binary representation\n    in ascending order. For similar number of ones, sort based on decimal value.\n\n    Args:\n        arr (list): A list of non-negative integers.\n\n    Returns:\n        list: A sorted list of integers based on the number of ones in their binary representation\n        and decimal value.\n    \"\"\"\n    def count_ones(n):\n        \"\"\"Count the number of ones in the binary representation of a number.\"\"\"\n    return bin(n).count('1')\n\n    # Use the sorted function to sort the array based on the count of ones in the binary representation\n    # and decimal value.\n    return sorted(arr, key=lambda x: (-count_ones(x), x))"}
{"task_id": "HumanEval/117", "solution": "def select_words(s, n):\n    \"\"\"\n    Returns a list of words from string s that contain exactly n consonants.\n\n    Args:\n        s (str): The input string.\n        n (int): The number of consonants to find.\n\n    Returns:\n        list: A list of words containing exactly n consonants.\n    \"\"\"\n    vowels = 'aeiou'\n    word = ''\n    words = set()\n\n    # Convert the string to lowercase to ignore case sensitivity\n    s = s.lower()\n\n    # Iterate over each character in the string\n    for word in s.split():\n        # Check if the character is not a vowel and has exactly n consonants\n        if not word and len(word) == n and any(c.isalpha() for c in word):\n            # Add the word to the set\n            word +=''\n            # Remove the space after adding the word\n        elif len(word) > 0:\n            # Join the word with spaces to get the final word\n            word +=''\n    return [w.strip() for w in s.split() if w.strip()]"}
{"task_id": "HumanEval/118", "solution": "def get_closest_vowel(word):\n    \"\"\"\n    Returns the closest vowel to the right from the end of the given word.\n\n    Args:\n    word (str): The input word.\n\n    Returns:\n    str: The closest vowel to the right from the end of the word.\n    \"\"\"\n    vowels = 'aeiou'\n    word_list = list(word)\n    left, right = 0, len(word) - 1\n    while left <= right:\n        if word[left] in vowels:\n            left += 1\n        else:\n            return word[left]\n        if word[right] in vowels:\n            right -= 1\n    return \"\""}
{"task_id": "HumanEval/119", "solution": "def match_parens(lst):\n    stack = [False] * len(lst)\n    for i, char in enumerate(lst):\n        stack[i % len(lst)] = char in ['(', ')']\n    for i in range(len(lst)):\n        if stack[i] == '(' and not stack[(i + 1) % len(lst)]:\n            return 'No'\n    return 'Yes'"}
{"task_id": "HumanEval/120", "solution": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr.\n    \n    Args:\n        arr (list): A list of integers.\n        k (int): A positive integer representing the length of the output list.\n    \n    Returns:\n        list: A sorted list of length k with the maximum k numbers in arr.\n    \"\"\"\n    # Sort the array in descending order\n    arr = sorted(arr, reverse=True)\n    \n    # Return the first k elements\n    return arr[:k]"}
{"task_id": "HumanEval/121", "solution": "def solution(lst):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Parameters:\n    lst (list): A non-empty list of integers.\n    \n    Returns:\n    int: The sum of all the odd elements that are in even positions.\n    \"\"\"\n    # Initialize the sum variable\n    total = 0\n    \n    # Iterate over the list with enumerate to get both index and value\n    for i, num in enumerate(lst):\n        # Check if the index is even and the number is odd\n        if i % 2 == 0 and num % 2!= 0:\n            # Add the number to the total\n            total += num\n    \n    return total"}
{"task_id": "HumanEval/122", "solution": "def sum_two_elements(arr, k):\n    \"\"\"\n    Returns the sum of the elements with at most two digits from the first k elements of arr.\n\n    Args:\n        arr (list): A non-empty list of integers.\n        k (int): The number of elements to consider from the first position.\n\n    Returns:\n        int: The sum of the elements with at most two digits from the first k elements.\n    \"\"\"\n    # Convert the input list to a set to remove duplicates and sort\n    unique_elements = sorted(set(arr))\n\n    # Initialize the sum to 0\n    total = 0\n\n    # Iterate through the first k elements\n    for num in unique_elements[:k]:\n        # Add the current element to the sum\n        total += num\n\n    return total\n\n# Test the function\narr = [111, 21, 3, 4000, 5, 6, 7, 8, 9]\nk = 4"}
{"task_id": "HumanEval/123", "solution": "def get_odd_collatz(n):\n    \"\"\"\n    Returns a sorted list of odd numbers in the Collatz sequence starting with n.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        list: A sorted list of odd numbers in the Collatz sequence.\n\n    Raises:\n        ValueError: If n is not a positive integer.\n\n    Example:\n        >>> get_odd_collatz(5)\n        [1, 5]\n    \"\"\"\n    def collatz_sequence(n):\n        \"\"\"\n        Recursive function to generate the Collatz sequence starting with n.\n        \"\"\"\n        if n == 1:\n            return [n]\n        elif n % 2 == 0:\n            # If n is even, return a list containing n\n            return [n]\n        else:\n            # If n is odd, generate the next number in the sequence\n            next_n = n * 3\n            return [n] + collatz_sequence(next_n)\n\n    # Generate the Collatz sequence starting with n\n    sequence = collatz_sequence(n)\n    return sorted([x for x in sequence if x > 0])  # Filter out the odd numbers"}
{"task_id": "HumanEval/124", "solution": "import re\ndef valid_date(date_str):\n    \"\"\"\n    Validates a given date string.\n\n    Args:\n    date_str (str): The date string to be validated.\n\n    Returns:\n    bool: True if the date is valid, False otherwise.\n    \"\"\"\n    # Define the valid date ranges for each month\n    month_range = {\n        '01': (1, 31),\n        '02': (29, 28),  # February has 29 days in leap years\n        '03': (1, 31),\n        '04': (1, 30),\n        '05': (1, 31),\n        '06': (1, 30),\n        '07': (1, 31),\n        '08': (1, 31),\n        '09': (1, 30),\n        '10': (1, 31),\n        '11': (1, 30),\n        '12': (1, 31)\n    }\n\n    # Split the date string into month, day, and year\n    month, day, year = map(int, date_str.split('-'))\n\n    # Check if the date is valid\n    if not (1 <= month in month_range and 1 <= day <= month_range[month][1] and 1 <= year <= 2039):\n        return False\n\n    return True"}
{"task_id": "HumanEval/125", "solution": "def split_words(txt):\n    \"\"\"\n    Given a string of words, return a list of words split on whitespace, \n    if no whitespaces exist in the text, return the number of lower case letters with odd order in the alphabet.\n    \"\"\"\n    words = txt.split()\n    result = []\n    for word in words:\n        if ',' in word:\n            result.append(word)\n        elif word[0].islower():\n            result.append(word)\n    return result"}
{"task_id": "HumanEval/126", "solution": "def is_sorted(lst):\n    \"\"\"\n    Given a list of numbers, return whether or not they are sorted in ascending order.\n    If the list has more than one duplicate of the same number, return False.\n    Assume no negative numbers and only integers.\n    \"\"\"\n    # Check if the list has duplicate numbers\n    for i in range(len(lst) - 1):\n        if lst[i] < lst[i + 1]:\n            return False\n    return True"}
{"task_id": "HumanEval/127", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef intersection(interval1, interval2):\n    \"\"\"Calculate the intersection of two intervals and check if its length is a prime number.\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n    intersection = max(start1, start2) - min(start1, end2) + 1\n    if start1 >= end1 and start2 >= end2:\n        return \"NO\"\n    if is_prime(intersection):\n        return \"YES\"\n    return \"NO\""}
{"task_id": "HumanEval/128", "solution": "def prod_signs(arr):\n    \"\"\"\n    Returns the sum of magnitudes of integers multiplied by product of all signs in the array.\n    If the array is empty, returns None.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int or None: The result of the calculation.\n    \"\"\"\n    # Check if array is empty\n    if not arr:\n        return None\n\n    # Calculate the product of all signs in the array\n    sign_product = 1\n    for num in arr:\n        sign_product *= -1 if num < 0 else 1\n\n    # Calculate the sum of magnitudes of integers in the array\n    magnitude_sum = sum(abs(num) for num in arr)\n\n    # Return the product of sign and magnitude\n    return sign_product * magnitude_sum"}
{"task_id": "HumanEval/129", "solution": "def minPath(grid, k):\n    \"\"\"\n    Find the minimum path of length k in the grid.\n\n    Args:\n    grid (list of lists): A 2D list of integers.\n    k (int): The length of the path.\n\n    Returns:\n    list of integers: The minimum path of length k.\n    \"\"\"\n    rows, cols = len(grid), len(grid[0])\n    visited = set()\n\n    def dfs(i, j, path):\n        \"\"\"Depth-First Search function to find the minimum path.\"\"\"\n        if i < 0 or i >= rows or j < 0 or j >= cols or (i, j) in visited:\n            return None\n        if i == k:\n            return path + [grid[i][j]]\n        visited.add((i, j))\n        min_val = float('inf')\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            x, y = i + dx, j + dy\n            if 0 <= x < rows and 0 <= y < cols and (x, y) not in visited:\n                path.append(grid[x][y])\n                min_val = min(min_val, dfs(x, y, path))\n        return min_val\n\n    return dfs(0, 0, [])\ngrid = [[1,2,3], [4,5,6], [7,8,9]]\nk = 3"}
{"task_id": "HumanEval/130", "solution": "def tri(n):\n    \"\"\"\n    Generates the first n + 1 numbers of the Tribonacci sequence.\n\n    Args:\n    n (int): The number of elements to generate.\n\n    Returns:\n    list: A list of the first n + 1 numbers of the Tribonacci sequence.\n    \"\"\"\n    sequence = [1, 1, 1]  # Initialize with the first three numbers of the sequence\n\n    for i in range(3, n + 1):\n        # Calculate the next number in the sequence using the recurrence relation\n        if i % 2 == 0:\n            next_number = 1 + (i / 2)\n        else:\n            next_number = 1 + (i / 2) + 1\n        sequence.append(next_number)\n\n    return sequence"}
{"task_id": "HumanEval/131", "solution": "def digits(n):\n    \"\"\"\n    Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    \"\"\"\n    result = 1\n    for digit in str(n):\n        if int(digit) % 2!= 0:\n            result *= int(digit)\n    return result"}
{"task_id": "HumanEval/132", "solution": "def is_nested(string):\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n        elif char in ['[', ']']:\n            stack.pop()\n    return not stack"}
{"task_id": "HumanEval/133", "solution": "def sum_squares(lst):\n    \"\"\"\n    This function calculates the sum of squared numbers in the given list, \n    rounding each element to the upper integer (Ceiling).\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of squared numbers in the list.\n    \"\"\"\n    return sum([x**2 for x in lst])"}
{"task_id": "HumanEval/134", "solution": "def check_if_last_char_is_a_letter(txt):\n    \"\"\"\n    Returns True if the last character of a given string is an alphabetical character and is not a word, False otherwise.\n\n    Parameters:\n    txt (str): The input string.\n\n    Returns:\n    bool: Whether the last character is an alphabetical character and not a word.\n    \"\"\"\n    # Check if the input string is not empty\n    if not txt:\n        return False\n\n    # Get the last character of the string\n    last_char = txt[-1]\n\n    # Check if the last character is an alphabetical character\n    return chr.isalpha(last_char)"}
{"task_id": "HumanEval/135", "solution": "def can_arrange(arr):\n    \"\"\"\n    Returns the largest index of an element which is not greater than or equal to the element immediately preceding it.\n    If no such element exists, returns -1.\n\n    Args:\n        arr (list): The input list of elements.\n\n    Returns:\n        int: The index of the largest element not greater than or equal to the preceding element, or -1 if no such element exists.\n    \"\"\"\n    if not arr:\n        return -1\n    return arr.index(max(arr) if len(arr) > 1 else -1)"}
{"task_id": "HumanEval/136", "solution": "def largest_smallest_integers(lst):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the largest of negative integers and 'b' is the smallest of positive integers in the list.\n    If there is no negative or positive integers, returns None.\n\n    Parameters:\n    lst (list): A list of integers.\n\n    Returns:\n    tuple: A tuple of two integers, where the first integer is the largest negative integer and the second integer is the smallest positive integer.\n    \"\"\"\n    # Filter the list to find negative integers and sort them in descending order\n    negative_integers = sorted([x for x in lst if x < 0], reverse=True)\n    \n    # If the list is empty or contains only negative integers, return None\n    if not negative_integers:\n        return None\n    \n    # Find the smallest positive integer in the list\n    smallest_positive_integer = min([x for x in lst if x > 0])\n    \n    # Return the largest negative integer and the smallest positive integer as a tuple\n    return (max(negative_integers), smallest_positive_integer)"}
{"task_id": "HumanEval/137", "solution": "def compare_one(a, b):\n    \"\"\"\n    Compare two values and return the larger value in the given variable type.\n\n    Args:\n        a (int or float): The first value to compare.\n        b (int or float): The second value to compare.\n\n    Returns:\n        int or str: The larger value in the given variable type, or None if the values are equal.\n    \"\"\"\n    if isinstance(a, str):\n        # If a is a string, compare as a float\n        if '.' in a:\n            return float(a) if '.' in b else a > b\n        else:\n            return a > b\n    elif isinstance(b, str):\n        # If b is a string, compare as a float\n        if '.' in b:\n            return float(b) if '.' in a else b > a\n        else:\n            return b > a\n    elif isinstance(a, float) and isinstance(b, float):\n        # If both a and b are floats\n        return float(a) > float(b)\n    else:\n        # If a and b are both integers\n        return a > b"}
{"task_id": "HumanEval/138", "solution": "def is_equal_to_sum_even(n):\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    \"\"\"\n    def helper(n):\n        \"\"\"\n        Recursively check if n can be written as the sum of exactly 4 positive even numbers.\n        \"\"\"\n        if n < 0:\n            return False\n        if n == 0:\n            return True\n        for i in range(1, n // 2 + 1):\n            if n % i == 0 and i >= 2 and is_even(i) and is_even(n - i):\n                return True\n        return False\n    def is_even(num):\n        \"\"\"\n        Check if a number is even.\n        \"\"\"\n        return num % 2 == 0\n    return helper(n)"}
{"task_id": "HumanEval/139", "solution": "import math\ndef special_factorial(n):\n    \"\"\"\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n\n    Args:\n    n (int): The input integer for which the factorial is calculated.\n\n    Returns:\n    int: The special factorial of the input integer.\n\n    Raises:\n    ValueError: If the input is a negative number.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result"}
{"task_id": "HumanEval/140", "solution": "def fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \"\"\"\n    result = \"\"\n    temp = \"\"\n    for char in text:\n        if char == \" \":\n            temp += char\n        elif len(temp) > 2 and temp == \"-\":\n            temp = \"\"\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/141", "solution": "def file_name_check(file_name):\n    \"\"\"\n    Checks if a file's name is valid based on the following conditions:\n    - No more than three digits\n    - Exactly one dot\n    - Substring before the dot must start with a latin alphabet\n    - Substring after the dot must be one of ['txt', 'exe', 'dll']\n\n    Args:\n    file_name (str): The name of the file to check.\n\n    Returns:\n    str: 'Yes' if the file's name is valid, 'No' otherwise.\n    \"\"\"\n    # Check if the file name is not empty\n    if not file_name:\n        return 'No'\n\n    # Check if the file name has more than three digits\n    if len(file_name) > 3:\n        return 'No'\n\n    # Check if the file name has a dot\n    if '.' not in file_name:\n        return 'No'\n\n    # Check if the substring before the dot starts with a latin alphabet\n    if not file_name[0].isalpha():\n        return 'No'\n\n    # Check if the substring after the dot is one of ['txt', 'exe', 'dll']\n    if file_name[1] not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    # If all checks pass, the file's name is valid\n    return 'Yes'"}
{"task_id": "HumanEval/142", "solution": "def sum_squares(lst):\n    \"\"\"\n    This function takes a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    \n    Parameters:\n    lst (list): A list of integers\n    \n    Returns:\n    int: The sum of all entries in the list\n    \n    Examples:\n    >>> sum_squares([1, 2, 3])\n    6\n    >>> sum_squares([])\n    0\n    >>> sum_squares([-1, -5, 2, -1, -5])\n    -126\n    \"\"\"\n    total = 0\n    for i, num in enumerate(lst):\n        if i % 3 == 0 and i % 4!= 0:\n            total += num ** 2\n        elif i % 4 == 0:\n            total += num ** 3\n    return total"}
{"task_id": "HumanEval/143", "solution": "def is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n <= 2:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef words_in_sentence(sentence):\n    \"\"\"\n    Returns a string containing the words from the original sentence whose lengths are prime numbers.\n    \"\"\"\n    words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return''.join(prime_words)"}
{"task_id": "HumanEval/144", "solution": "def simplify(x, n):\n    \"\"\"\n    Simplify the expression x * n.\n\n    Args:\n        x (str): The numerator of the fraction.\n        n (str): The denominator of the fraction.\n\n    Returns:\n        bool: True if x * n evaluates to a whole number, False otherwise.\n    \"\"\"\n    def gcd(x, y):\n        \"\"\"Calculate the greatest common divisor of two numbers using the Euclidean algorithm.\"\"\"\n        while y:\n            temp = y\n            y = (x % y)\n            x = temp\n        return x\n\n    gcd_value = gcd(int(x), int(n))\n    return gcd(x, n) == 1"}
{"task_id": "HumanEval/145", "solution": "def order_by_points(nums):\n    \"\"\"\n    Sorts the given list of integers in ascending order based on the sum of their digits.\n    If there are multiple items with the same sum of digits, their original order is preserved.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        list: The sorted list of integers.\n    \"\"\"\n    def sum_digits(n):\n        \"\"\"Calculates the sum of digits of a given integer.\"\"\""}
{"task_id": "HumanEval/146", "solution": "def specialFilter(nums):\n    \"\"\"\n    Returns the number of elements in the array that are greater than 10 and both first and last digits of a number are odd.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        int: The count of numbers that meet the conditions.\n    \"\"\"\n    count = 0"}
{"task_id": "HumanEval/147", "solution": "def get_max_triples(n):\n    \"\"\"\n    Returns the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n    \"\"\"\n    # Initialize a dictionary to store the count of triples\n    triples = {}\n\n    # Generate the array a of length n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                # Check if the sum of a[i], a[j], and a[k] is a multiple of 3\n                if (i - 1) % 3 == (j - 1) % 3 == (k - 1) % 3:\n                    triples[(i, j, k)] = triples.get((i, j, k), 0) + 1\n    # Return the count of triples\n    return len(triples)\nn = 5"}
{"task_id": "HumanEval/148", "solution": "def closest_orbits(planet1, planet2):\n    \"\"\"\n    Returns a tuple of planets whose orbits are between planet1 and planet2, \n    sorted by proximity to the Sun.\n\n    Args:\n        planet1 (str): The first planet name.\n        planet2 (str): The second planet name.\n\n    Returns:\n        tuple: A tuple of planets whose orbits are between planet1 and planet2,\n            sorted by proximity to the Sun.\n    \"\"\"\n    # Define the order of the planets\n    order = [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Earth\"]\n\n    # Convert the input planet names to lowercase\n    planet1 = planet1.lower()\n    planet2 = planet2.lower()\n\n    # Check if the input planet names are valid\n    if planet1 not in [\"mercury\", \"venus\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"]:\n        return \"\"\n    if planet2 not in [\"mercury\", \"venus\", \"mars\", \"jupiter\", \"saturn\", \"uranus\", \"neptune\"]:\n        return \"\"\n\n    # Find the index of the first planet in the order list\n    index = order.index(planet1)\n    # Find the index of the second planet in the order list\n    index2 = order.index(planet2)\n\n    # Slice the order list to get the planets between the two\n    planets = order[index:index+1]\n\n    # Sort the sliced list and return it\n    return tuple(sorted(planets))\n\n# Test the function"}
{"task_id": "HumanEval/149", "solution": "def list_sort(lst):\n    \"\"\"\n    This function accepts a list of strings, removes strings with odd lengths, \n    and returns a sorted list of strings in ascending order by length, \n    while preserving alphabetical order for words of equal length.\n    \n    Parameters:\n    lst (list): A list of strings\n    \n    Returns:\n    list: A sorted list of strings\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list by length and then alphabetically\n    sorted_list = sorted(filtered_list)\n    \n    return sorted_list\n\n# Test cases"}
{"task_id": "HumanEval/150", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is a prime number and should return the value of y otherwise.\"\"\"\n    if is_prime(n):\n        return x\n    else:\n        return y"}
{"task_id": "HumanEval/151", "solution": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The sum of squares of the odd numbers in the list.\n    \"\"\"\n    # Filter out non-integer and negative numbers\n    numbers = [num for num in lst if isinstance(num, int) and num >= 0]\n    \n    # Use list comprehension to square the odd numbers\n    squares = [num ** 2 for num in numbers if num % 2!= 0]\n    \n    # Return the sum of the squares\n    return sum(squares)"}
{"task_id": "HumanEval/152", "solution": "def compare(game, guess):\n    \"\"\"\n    This function compares a given guess with a list of scores to determine how far off each guess was.\n\n    Args:\n    game (list): A list of scores\n    guess (list): A list of guesses\n\n    Returns:\n    list: A list of the same length as the input lists, where each value is the difference between the guess and the score at the corresponding index.\n    \"\"\"\n    # Initialize an empty list to store the results\n    result = [0, 0, 0, 0, 0, 0]\n\n    # Calculate the length of the input lists\n    len_game = len(game)\n    len_guess = len(guess)\n\n    # Iterate over the lists\n    for i in range(len_game):\n        # Calculate the absolute difference between the guess and the score\n        result[i] = abs(guess[i] - game[i])\n\n    # Return the result\n    return result"}
{"task_id": "HumanEval/153", "solution": "def strongest_extension(class_name, extensions):\n    \"\"\"\n    This function finds the strongest extension to a given class.\n\n    Parameters:\n    class_name (str): The name of the class.\n    extensions (list): A list of extensions.\n\n    Returns:\n    str: The strongest extension name.\n\n    Example:\n    strongest_extension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n    \"\"\"\n    # Initialize the strongest extension with the first extension in the list\n    strongest_ext = next(iter(extensions))\n\n    # Iterate over the list of extensions\n    for ext in extensions:\n        # Calculate the strength of the current extension\n        strength = len(ext.upper()) - len(ext.lower())\n\n        # If the current extension is stronger than the strongest extension found so far,\n        # update the strongest extension\n        if strength > len(strongest_ext) - 1:\n            strongest_ext = ext\n\n    # Return the strongest extension\n    return str(class_name) + \".\" + strongest_ext\n\n# Test the function"}
{"task_id": "HumanEval/154", "solution": "def cycpattern_check(a, b):\n    \"\"\"\n    This function checks if the second word or any of its rotations is a substring in the first word.\n    \n    Parameters:\n    a (str): The first word\n    b (str): The second word to check\n    \n    Returns:\n    bool: True if the second word or any of its rotations is a substring in the first word, False otherwise\n    \"\"\"\n    # Check if a is a substring of b\n    for i in range(len(b)):\n        if b[i:] + b[:i] in a:\n            return True\n    return False"}
{"task_id": "HumanEval/155", "solution": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\"\"\"\n    # Convert the number to a string to easily iterate over each digit\n    num_str = str(abs(num))\n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n\n    # Iterate over each character (digit) in the string\n    for char in num_str:\n        # Check if the digit is even\n        if int(char) % 2 == 0:\n            even_count += 1\n        # Check if the digit is odd\n        else:\n            odd_count += 1\n\n    # Return the counts as a tuple\n    return (even_count, odd_count)"}
{"task_id": "HumanEval/156", "solution": "def int_to_mini_roman(num):\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\n    Restrictions: 1 <= num <= 1000\n    \"\"\"\n    # Define a dictionary to map integers to their roman numeral equivalents\n    roman_numerals = {\n        1000:'m',\n        900: 'cm',\n        400: 'd',\n        500: 'c',\n        100: 'l',\n        50: 'x',\n        10: 'v',\n        5: 'v',\n        1: 'i'\n    }\n\n    # Initialize an empty string to store the result\n    result = ''\n\n    # Convert the input integer to a string\n    num_str = str(num)\n\n    # Iterate over the dictionary in descending order of values\n    for value, numeral in sorted((value for value in roman_numerals if num < value), reverse=True):\n        # Calculate the count of the current value\n        count = num // value\n        # Append the numeral to the result string, repeating it as necessary\n        result += numeral * count\n\n    return result"}
{"task_id": "HumanEval/157", "solution": "def right_angle_triangle(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n\n    A right-angled triangle is a triangle in which one angle is right angle or 90 degree.\n    \"\"\"\n    # Calculate the square of each side length\n    a_squared = a ** 2\n    b_squared = b ** 2\n    c_squared = c ** 2\n\n    # Check if the triangle is right-angled\n    # If a**2 + b**2 <= c**2, it is right-angled\n    if a_squared + b_squared <= c_squared:\n        return True\n    else:\n        return False"}
{"task_id": "HumanEval/158", "solution": "def find_max(words):\n    \"\"\"\n    Find the word with the maximum number of unique characters in a list of strings.\n    If multiple strings have the maximum number of unique characters, return the one that comes first in lexicographical order.\n\n    Args:\n        words (list): A list of strings.\n\n    Returns:\n        str: The word with the maximum number of unique characters.\n    \"\"\"\n    # Initialize an empty dictionary to store the frequency of each character in each word\n    char_freq = {}\n\n    # Iterate through each word in the list\n    for word in words:\n        # Initialize an empty set to store unique characters in the current word\n        unique_chars = set()\n        # Count the unique characters in the current word\n        for char in word:\n            unique_chars.add(char)\n        # Update the dictionary with the current word and its unique characters\n        char_freq[word] = len(unique_chars)\n\n    # Find the word with the maximum unique characters\n    max_word = max(char_freq, key=char_freq.get)\n\n    # Return the word with the maximum unique characters\n    return max_word"}
{"task_id": "HumanEval/159", "solution": "import math\ndef eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    You should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Parameters:\n    number (int): the number of carrots that you have eaten.\n    need (int): the number of carrots that you need to eat.\n    remaining (int): the number of carrots that thet exist in stock\n    \n    Returns:\n    list: a list of two integers, the total number of eaten carrots and the number of carrots left.\n    \"\"\"\n    if number >= need:\n        eaten = number\n        remaining -= number\n        return [number, remaining]\n    else:\n        eaten = 0\n        remaining -= need\n        return [number, remaining]"}
{"task_id": "HumanEval/160", "solution": "import operator"}
{"task_id": "HumanEval/161", "solution": "def solve(s):\n    \"\"\"Reverses the case of a string and removes non-letter characters.\"\"\"\n    result = \"\"\n    for char in s:\n        if char.isalpha():\n            if char.isupper():\n                result += char.upper()\n            else:\n                result += char.lower()\n        else:\n            result += char\n    return result"}
{"task_id": "HumanEval/162", "solution": "import hashlib\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world')\n    '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    # Check if the input is an empty string\n    if not text:\n        return None\n\n    # Create an MD5 hash object\n    md5 = hashlib.md5()\n\n    # Update the hash object with the input text\n    md5.update(text.encode('utf-8'))\n\n    # Return the hash as a hexadecimal string\n    return md5.hexdigest()"}
{"task_id": "HumanEval/163", "solution": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    Args:\n    a (int): The start of the range (inclusive)\n    b (int): The end of the range (inclusive)\n\n    Returns:\n    list: A list of even digits between a and b in ascending order\n    \"\"\"\n    even_digits = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            even_digits.append(i)\n    return even_digits"}
